##############################################
# 순서별로 정렬 
arr = [(1,2),(2,3),(3,1)]
# 1번째를 기준으로 정렬 
arr = sorted(arr, key = lambda x : x[1])
print(arr)
##############################################
# 큐 :
from collections import deque
##############################################
# 조합, 순열 
from itertools import combinations
from itertools import permutations
##############################################
# dict은 그냥 쓰면 된다.
##############################################
# 브루트 포스의 종류 
# 1. for문 
# 2. 재귀함수를 이용 
##############################################
# bfs (큐) : 최소거리인 경우에는 큐를 사용한다.
##############################################
# 다익스트라.
# 1. 우선순위 큐 
# 2. 그래프 
##############################################
# 다익스트라 로직 (특정 하나의 위치에서 최단 거리를 구하는 로직.)
# 0. 시작 위치의 dp 를 0으로 초기화 하고 나머지것들은 max로 설정한다.
# 1. 방문하지 않은 정점중에서 거리가 가장 짧은 노드를 선택한다.
# 2. 거리가 가장 짧은 노드에서 연결되는 것 중에서 최단 거리가 있으면 지정한다.

##############################################
# . 우선순위 큐를 사용하는 방법 
# 1. (거리, 노드)의 형태로 넣는다. 
# * 파이썬의 우선순위는 min heap 이 기본이고 max heap을 하는 경우 -를 사용하면 된다.
# 2. 가장 짧은 것을 뽑는다.
# 3. 방문한 적 (뽑는 거리가 더 크다면 방문한적이 있다고 판단한다.)이 있으면 continue  
# 4. 최소 값으로 갱신하는 경우에는 큐에 값을 집어 넣는다.

##############################################
# 다익스트라 (힙 큐를 이용한 구현)

##############################################
# 힙큐 사용법 
import heapq
n = 7
adj  = [[],[],[],[]]
def dijkstra(start) :
    q = []
    distance = [987654321] * n
    distance[start] = 0

    start = 1
    heapq.heappush(q,(0,start))
    while q :
        dist,now = heapq.heappop()
        #처리된 적이 있으면 처리하지 않는다.
        if (dist > distance[now]):
            continue
        # 연결되어 있는 것을 모두 돌면서
        # 현재 값보다 작게 갱신할 수 있으면 갱신하고 
        # 힙에 넣는다.
        for i in adj[now]:
            cost = dist+ i[1] 
            if (cost < distance[i[0]]):
                distance[i[0]] = cost
                heapq.heappush(q,(cost,i[0]))
    

##############################################
# 크루스칼 
# 1. 유니온 파이드 : 부모를 찾는 로직을 만들고 
# 2. 유니온 파인드를 이용해서 사이클을 찾는다.
# 3. 사이클이 없는 지 판단하고 간선을 추가한다. (간선 추가 시에는 그리디하게 가장 작은 값만 넣는다.)
#    -- 간선의 갯수만큼 시행하면 된다
# 4. 마지막 탈출 조건은 모르겠다.

##############################################
# 크루스칼 2 (동빈나 정리)
# 1. 간선을 오름차순으로 정렬한다.
# 2. 같은 부모가 아니라면 추가한다. (사이클이 아니라면)
# 3. 반복
##############################################
# 플로이드 워셜 포드 
# 1. 그만 n^3 
n = 10
graph = [[0]*n for i in range(n)]
print(graph)
for k in range(1,n+1):
    for i in range(1,n+1):     # 여기가 시작점
        for j in range(1,n+1): # 여기가 종료점
            graph[i][j] = min (graph[i][k]+ graph[k][j] , graph[i][j])
##############################################
# SQL 정리.
# ROWNUM > 10 같이 
##############################################
# 최대값은 int(1e9)로 선언하자.
#



###############################################
# itertools:combination  / collections :heapq 헷갈린다. 
# heapq 는 그냥 import 하면되고  heapq.heappush() heapq.heappop()

################################################
# .join을 사용하면 리스트를 문자열로 바꿀 수 있다.
print(''.join(list111))